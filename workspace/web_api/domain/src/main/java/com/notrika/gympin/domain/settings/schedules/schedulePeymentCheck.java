package com.notrika.gympin.domain.settings.schedules;

import com.notrika.gympin.common.finance.IncreaseUserDeposit.enums.DepositStatus;
import com.notrika.gympin.common.finance.gateway.AutoGenerated.ClientConfirmRequestData;
import com.notrika.gympin.common.finance.gateway.AutoGenerated.ClientConfirmResponseData;
import com.notrika.gympin.common.finance.gateway.service.GatewayBankService;
import com.notrika.gympin.common.finance.transaction.enums.GatewayType;
import com.notrika.gympin.common.util.GeneralUtil;
import com.notrika.gympin.common.util.exception.transactions.TransactionAlreadyChecked;
import com.notrika.gympin.common.util.exception.transactions.TransactionNotFound;
import com.notrika.gympin.common.util.exception.transactions.unknownPaymentBuyer;
import com.notrika.gympin.domain.finance.gateways.parsian.FailureMessageProvider;
import com.notrika.gympin.domain.finance.peyments.CalculatePaymentsServiceImpl;
import com.notrika.gympin.persistence.dao.repository.finance.FinanceSerialRepository;
import com.notrika.gympin.persistence.dao.repository.finance.gateway.FinanceGatewayRepository;
import com.notrika.gympin.persistence.dao.repository.finance.request.FinanceIncreaseUserDepositRequestRepository;
import com.notrika.gympin.persistence.entity.finance.FinanceSerialEntity;
import com.notrika.gympin.persistence.entity.finance.gateway.FinanceGatewayEntity;
import com.notrika.gympin.persistence.entity.finance.user.requests.FinanceIncreaseUserDepositRequestEntity;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
@Slf4j
public class schedulePeymentCheck {

    @Autowired
    FinanceIncreaseUserDepositRequestRepository financeIncreaseUserDepositRequestRepository;

    @Autowired
    FinanceSerialRepository financeSerialRepository;

    @Autowired
    FinanceGatewayRepository financeGatewayRepository;

    @Autowired
    GatewayBankService gatewayBankService;

    @Autowired
    CalculatePaymentsServiceImpl calculatePeymentsService;

    public void checkUserPendingPayments() {
        log.error("Going to checkPendingPayments\n");
        List<FinanceSerialEntity> pendingSerial = financeSerialRepository.findAllUserPendingPayments(GatewayType.BANK_PORTAL, DepositStatus.BANK_PENDING)
                .stream().filter(p->{
            long diffMillis = new Date().getTime() - p.getCreatedDate().getTime();
            long diffMinutes = TimeUnit.MILLISECONDS.toMinutes(diffMillis);
            return diffMinutes > 15;
        }).collect(Collectors.toList());
        for (FinanceSerialEntity request : pendingSerial) {
            log.error("Going to checkPendingPayments for transactionId :" + request.getId() + "\n");
            try {
                getUserTransactionRequestResult(request, request.getUserIncreases().get(0));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void getUserTransactionRequestResult(FinanceSerialEntity serial, FinanceIncreaseUserDepositRequestEntity request) {


        String message = "";
        Long OrderId = GeneralUtil.UnifyOrderId(serial.getId());
        var result = false;
        ClientConfirmRequestData requestData = new ClientConfirmRequestData();
        FinanceGatewayEntity parsianSetting = null;
        try {
            parsianSetting = financeGatewayRepository.findAll().stream().filter(o -> !o.isDeleted()).filter(p -> p.getData1() != null).filter(f -> f.getData1().equals("PARSIAN")).collect(Collectors.toList()).get(0);
        } catch (Exception e) {
            message += "request fail -> can not get parsian setting ";
        }
        requestData.setLoginAccount(parsianSetting.getPassword());
        requestData.setToken(Long.parseLong(request.getRefrenceCode()));
        try {
            ClientConfirmResponseData clientConfirmResponseData = gatewayBankService.confirmPaymentRequest(requestData);
            if (clientConfirmResponseData.getStatus() == 0 && clientConfirmResponseData.getRRN() > 0) {
                    message +=
                            " RNN : " + clientConfirmResponseData.getRRN() + "\n" +
                                    " Gateway Token : " + clientConfirmResponseData.getToken() + "\n" +
                                    " Card Hash : " + clientConfirmResponseData.getCardNumberMasked();

                result = true;
            } else {
                    message += FailureMessageProvider.getMessage(clientConfirmResponseData.getStatus());
            }
        } catch (Exception e) {
                message += FailureMessageProvider.getMessage((short) -300);
        }

        request.setDescription(message);
        financeIncreaseUserDepositRequestRepository.update(request);
        try {
            message += "CallbackMethod CalculatePayment ";
            calculatePeymentsService.CalculatePayment(GeneralUtil.PureOrderId(OrderId), result, message, "");
        } catch (TransactionNotFound e) {
            result = false;
            message += FailureMessageProvider.getMessage((short) -311) + OrderId;
            request.setDescription(message);
            financeIncreaseUserDepositRequestRepository.update(request);
        } catch (unknownPaymentBuyer e) {
            result = false;
            message += FailureMessageProvider.getMessage((short) -312) + OrderId;
            request.setDescription(message);
            financeIncreaseUserDepositRequestRepository.update(request);
        } catch (TransactionAlreadyChecked e) {
            result = false;
            message += FailureMessageProvider.getMessage((short) -313) + OrderId;
            request.setDescription(message);
            financeIncreaseUserDepositRequestRepository.update(request);
        } catch (Exception e) {
            result = false;
            message += FailureMessageProvider.getMessage((short) -310) + OrderId;
            request.setDescription(message);
            financeIncreaseUserDepositRequestRepository.update(request);
        }

    }
}
